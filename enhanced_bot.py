import asyncio
import logging
import os
import json
from aiogram import Bot, Dispatcher, types, F
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery
from aiogram.filters import CommandStart, Command
from aiogram.enums import ContentType, ChatMemberStatus, ChatAction

# Configuration
API_TOKEN = "7686244968:AAHb1w8ybeNmRqEpmeTnX24dDkeGS6PUm8M"
ADMIN_ID = 7201285915
CHANNEL_USERNAME = "@flex_public"
CHANNEL_ID = "@flex_public"  # Make sure this channel exists and bot is admin

# Global variables for user management
user_ids = set()
blocked_users = set()
verified_users = set()

def load_blocked_users():
    global blocked_users
    try:
        with open("blocked_users.txt", "r") as f:
            blocked_users = {int(line.strip()) for line in f if line.strip()}
    except FileNotFoundError:
        blocked_users = set()
    except Exception as e:
        print(f"Error loading blocked users: {e}")
        blocked_users = set()

def save_blocked_users():
    try:
        with open("blocked_users.txt", "w") as f:
            for user_id in blocked_users:
                f.write(f"{user_id}\n")
    except Exception as e:
        print(f"Error saving blocked users: {e}")

def load_verified_users():
    global verified_users
    try:
        with open("verified_users.txt", "r") as f:
            verified_users = {int(line.strip()) for line in f if line.strip()}
    except FileNotFoundError:
        verified_users = set()
    except Exception as e:
        print(f"Error loading verified users: {e}")
        verified_users = set()

def save_verified_users():
    try:
        with open("verified_users.txt", "w") as f:
            for user_id in verified_users:
                f.write(f"{user_id}\n")
    except Exception as e:
        print(f"Error saving verified users: {e}")

def save_user_ids():
    try:
        with open("user_ids.txt", "w") as f:
            for user_id in user_ids:
                f.write(f"{user_id}\n")
    except Exception as e:
        print(f"Error saving user IDs: {e}")

def load_user_ids():
    global user_ids
    try:
        with open("user_ids.txt", "r") as f:
            user_ids = {int(line.strip()) for line in f if line.strip()}
    except FileNotFoundError:
        user_ids = set()
    except Exception as e:
        print(f"Error loading user IDs: {e}")
        user_ids = set()

# Load all data on startup
load_blocked_users()
load_verified_users()
load_user_ids()

# Setup logging - reduce verbosity but keep errors
logging.basicConfig(
    level=logging.WARNING,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Initialize bot
bot = Bot(token=API_TOKEN)
dp = Dispatcher()

async def show_typing_animation(chat_id: int, action_type: ChatAction = ChatAction.TYPING):
    """Enhanced loading animation with multiple stages and emojis"""
    try:
        # Stage 1: Initial loading
        if action_type == ChatAction.TYPING:
            status_msg = await bot.send_message(chat_id, "‚è≥ **Loading Premium Key Generator...**", parse_mode="Markdown")
        else:
            status_msg = await bot.send_message(chat_id, "‚è≥ **Loading Download Manager...**", parse_mode="Markdown")
        
        await bot.send_chat_action(chat_id, action_type)
        await asyncio.sleep(1.0)
        
        # Stage 2: Processing with spinner
        loading_emojis = ["üîÑ", "‚ö°", "üîÉ", "‚≠ê"]
        for i, emoji in enumerate(loading_emojis):
            if action_type == ChatAction.TYPING:
                try:
                    await status_msg.edit_text(f"{emoji} **Processing premium access...** {emoji}", parse_mode="Markdown")
                except Exception:
                    pass
            else:
                try:
                    await status_msg.edit_text(f"{emoji} **Preparing download...** {emoji}", parse_mode="Markdown")
                except Exception:
                    pass
            
            await bot.send_chat_action(chat_id, action_type)
            await asyncio.sleep(0.8)
        
        # Stage 3: Security verification
        if action_type == ChatAction.TYPING:
            try:
                await status_msg.edit_text("üîê **Verifying premium membership...** üõ°Ô∏è", parse_mode="Markdown")
            except Exception:
                pass
        else:
            try:
                await status_msg.edit_text("üõ°Ô∏è **Verifying download permissions...** üîê", parse_mode="Markdown")
            except Exception:
                pass
        
        await bot.send_chat_action(chat_id, action_type)
        await asyncio.sleep(1.2)
        
        # Stage 4: Generation/Preparation with progress
        progress_bars = ["‚ñ±‚ñ±‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ±‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ±‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ±‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ±", "‚ñ∞‚ñ∞‚ñ∞‚ñ∞‚ñ∞"]
        for i, bar in enumerate(progress_bars):
            if action_type == ChatAction.TYPING:
                try:
                    await status_msg.edit_text(f"üîë **Generating activation key...** {bar}", parse_mode="Markdown")
                except Exception:
                    pass
            else:
                try:
                    await status_msg.edit_text(f"üì± **Preparing APK package...** {bar}", parse_mode="Markdown")
                except Exception:
                    pass
            
            await bot.send_chat_action(chat_id, action_type)
            await asyncio.sleep(0.6)
        
        # Stage 5: Final loading with sparkles
        final_emojis = ["‚ú®", "üåü", "‚≠ê", "üí´"]
        for emoji in final_emojis:
            if action_type == ChatAction.TYPING:
                try:
                    await status_msg.edit_text(f"{emoji} **Key generation complete!** {emoji}", parse_mode="Markdown")
                except Exception:
                    pass
            else:
                try:
                    await status_msg.edit_text(f"{emoji} **APK package ready!** {emoji}", parse_mode="Markdown")
                except Exception:
                    pass
            
            await bot.send_chat_action(chat_id, action_type)
            await asyncio.sleep(0.5)
        
        # Stage 6: Ready to deliver
        if action_type == ChatAction.TYPING:
            try:
                await status_msg.edit_text("üöÄ **Delivering your premium key...** üéØ", parse_mode="Markdown")
            except Exception:
                pass
        else:
            try:
                await status_msg.edit_text("üöÄ **Uploading premium APK...** üì¶", parse_mode="Markdown")
            except Exception:
                pass
        
        await bot.send_chat_action(chat_id, action_type)
        await asyncio.sleep(1.0)
        
        # Delete status message after animation
        try:
            await status_msg.delete()
        except Exception:
            pass
        
    except Exception as e:
        print(f"Error showing loading animation: {e}")
        # Fallback simple animation
        try:
            await bot.send_chat_action(chat_id, action_type)
            await asyncio.sleep(3)
        except Exception:
            pass

async def check_channel_membership(user_id):
    try:
        # Admin always has access
        if user_id == ADMIN_ID:
            print(f"‚úÖ Admin access granted for ID: {user_id}")
            return True

        print(f"üîç Checking membership for user {user_id} in channel {CHANNEL_ID}")
        
        try:
            # Force fresh check by clearing cache
            member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
            print(f"üîç Member status for {user_id}: {member.status}")

            # Check for valid membership statuses
            valid_statuses = [ChatMemberStatus.MEMBER, ChatMemberStatus.CREATOR, ChatMemberStatus.ADMINISTRATOR]
            
            if member.status in valid_statuses:
                print(f"‚úÖ User {user_id} is a valid member with status: {member.status}")
                verified_users.add(user_id)
                save_verified_users()
                return True
            elif member.status == ChatMemberStatus.LEFT:
                print(f"‚ùå User {user_id} has left the channel")
                if user_id in verified_users:
                    verified_users.remove(user_id)
                    save_verified_users()
                return False
            elif member.status == ChatMemberStatus.KICKED:
                print(f"‚ùå User {user_id} is banned from the channel")
                if user_id in verified_users:
                    verified_users.remove(user_id)
                    save_verified_users()
                return False
            else:
                print(f"‚ùå User {user_id} has invalid status: {member.status}")
                if user_id in verified_users:
                    verified_users.remove(user_id)
                    save_verified_users()
                return False

        except Exception as e:
            print(f"‚ö†Ô∏è API Error checking membership for {user_id}: {e}")
            # For testing, return False to force proper membership check
            return False

    except Exception as e:
        print(f"‚ùå Critical error in membership check for {user_id}: {e}")
        return False

def get_welcome_keyboard():
    buttons = [
        [InlineKeyboardButton(text="üöÄ Join Premium Channel", url="https://t.me/flex_public")],
        [InlineKeyboardButton(text="‚úÖ Verify Membership", callback_data="check_joined")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_content_keyboard():
    buttons = [
        [
            InlineKeyboardButton(text="üîê Get Activation Key", callback_data="get_key"),
            InlineKeyboardButton(text="üì± BGMI APK", callback_data="get_apk")
        ]
    ]
    return InlineKeyboardMarkup(inline_keyboard=buttons)

@dp.message(CommandStart())
async def send_welcome(message: Message):
    try:
        user_ids.add(message.from_user.id)
        save_user_ids()

        if message.from_user.id in blocked_users:
            await message.reply("üö´ **Access Denied**\n\nYour account has been restricted from using this service.")
            return

        welcome_text = """üéØ **Welcome to FlexBot Premium Services** üéØ

üåü **Exclusive Access to Premium Content**
üîê **Advanced Graphics Tools & Resources** 
üì± **Latest BGMI Premium Collections**
üé® **Cutting-Edge Design Assets**

‚ö° **To Access Premium Features:**
üìå Join our exclusive channel to unlock premium content
üîì Verify your membership to proceed"""

        await message.reply(welcome_text, reply_markup=get_welcome_keyboard(), parse_mode="Markdown")
    except Exception as e:
        print(f"Error in welcome handler: {e}")
        await message.reply("ü§ñ **Bot Started Successfully!**\n\nWelcome to FlexBot Premium Services!")

@dp.callback_query(F.data == "check_joined")
async def check_joined(callback_query: CallbackQuery):
    try:
        await callback_query.answer()
        user_id = callback_query.from_user.id

        if user_id in blocked_users:
            await callback_query.message.edit_text("üö´ **Access Denied**\n\nYour account has been restricted from accessing this service.")
            return

        # Show loading animation for membership check
        loading_msg = await callback_query.message.edit_text("üîç **Checking membership status...** ‚è≥", parse_mode="Markdown")
        
        # Loading animation for membership check
        check_emojis = ["üîç", "üîé", "üëÅÔ∏è", "üõ°Ô∏è"]
        for emoji in check_emojis:
            try:
                await loading_msg.edit_text(f"{emoji} **Verifying your membership...** {emoji}", parse_mode="Markdown")
                await asyncio.sleep(0.8)
            except Exception:
                pass

        is_member = await check_channel_membership(user_id)

        if is_member:
            verified_users.add(user_id)
            save_verified_users()

            thank_you_text = """üéâ **Membership Verified Successfully** üéâ

‚úÖ **Premium Access Granted**
üîì **All Features Unlocked**
‚≠ê **Welcome to the Elite Community**

Choose your desired content:"""

            await callback_query.message.edit_text(thank_you_text, reply_markup=get_content_keyboard(), parse_mode="Markdown")
        else:
            not_joined_text = """‚ùå **Membership Verification Failed**

üì¢ Please join our premium channel first to access exclusive content.
üîÑ After joining, click "‚úÖ Verify Membership" to proceed."""

            await callback_query.message.edit_text(not_joined_text, reply_markup=get_welcome_keyboard(), parse_mode="Markdown")
    except Exception as e:
        print(f"Error in check_joined: {e}")

@dp.callback_query(F.data == "get_key")
async def get_key(callback_query: CallbackQuery):
    try:
        await callback_query.answer()
        user_id = callback_query.from_user.id

        if user_id in blocked_users:
            await callback_query.message.edit_text("üö´ **Access Denied**")
            return

        is_member = await check_channel_membership(user_id)

        if not is_member:
            await callback_query.message.edit_text(
                "‚ùå **Premium Membership Required**\n\nPlease join our channel first!",
                reply_markup=get_welcome_keyboard(),
                parse_mode="Markdown"
            )
            return

        # Show typing animation before sending key
        await show_typing_animation(user_id, ChatAction.TYPING)

        try:
            with open("key.txt", "r", encoding="utf-8") as f:
                key_text = f.read().strip()

            await bot.send_message(user_id, f"üîê **Premium Activation Key**\n\n`{key_text}`\n\n‚úÖ Tap the key above to copy it!", parse_mode="Markdown")
        except FileNotFoundError:
            await callback_query.message.reply("‚ùå **Key Currently Unavailable**\n\nPlease try again later.")
    except Exception as e:
        print(f"Error in get_key: {e}")

@dp.callback_query(F.data == "get_apk")
async def get_apk(callback_query: CallbackQuery):
    try:
        await callback_query.answer()
        user_id = callback_query.from_user.id

        if user_id in blocked_users:
            await callback_query.message.edit_text("üö´ **Access Denied**")
            return

        is_member = await check_channel_membership(user_id)

        if not is_member:
            await callback_query.message.edit_text(
                "‚ùå **Premium Membership Required**\n\nPlease join our channel first!",
                reply_markup=get_welcome_keyboard(),
                parse_mode="Markdown"
            )
            return

        # Show uploading animation before sending APK
        await show_typing_animation(user_id, ChatAction.UPLOAD_DOCUMENT)

        try:
            with open("apk_file_id.txt", "r") as f:
                file_id = f.read().strip()

            try:
                with open("apk_caption.txt", "r", encoding="utf-8") as f:
                    caption = f.read().strip()
            except FileNotFoundError:
                caption = "üì± BGMI Premium Collection"

            await bot.send_document(user_id, file_id, caption=caption)
        except FileNotFoundError:
            await callback_query.message.reply("‚ùå **APK Currently Unavailable**\n\nPlease check back later.")
    except Exception as e:
        print(f"Error in get_apk: {e}")

@dp.message(Command("setkey"))
async def set_key(message: Message):
    try:
        if message.from_user.id != ADMIN_ID:
            return

        command_args = message.text.split(' ', 1)
        key_text = command_args[1] if len(command_args) > 1 else ""

        if not key_text:
            await message.reply("**Usage:** `/setkey Your Premium Key Text`")
            return

        with open("key.txt", "w", encoding="utf-8") as f:
            f.write(key_text)
        await message.reply("‚úÖ **Activation Key Updated Successfully**")
    except Exception as e:
        print(f"Error in set_key: {e}")

@dp.message(F.content_type == ContentType.DOCUMENT)
async def set_apk(message: Message):
    try:
        if message.from_user.id != ADMIN_ID:
            return

        if not message.caption or not message.caption.startswith('/setapk'):
            return

        file = message.document
        file_id = file.file_id
        caption = message.caption.replace('/setapk', '').strip() or "üì± BGMI Premium Collection"

        with open("apk_file_id.txt", "w") as f:
            f.write(file_id)
        with open("apk_caption.txt", "w", encoding="utf-8") as f:
            f.write(caption)
        await message.reply("‚úÖ **Premium APK Updated Successfully**")
    except Exception as e:
        print(f"Error in set_apk: {e}")

@dp.message(Command("broadcast"))
async def broadcast_message(message: Message):
    """Enhanced broadcast command with custom button support"""
    if message.from_user.id != ADMIN_ID:
        await message.reply(f"‚ùå **Access Denied**\n\nOnly admin can use broadcast")
        return

    # Force reload user data
    load_user_ids()
    load_verified_users() 
    load_blocked_users()
    
    # Ensure admin is in user_ids
    if ADMIN_ID not in user_ids:
        user_ids.add(ADMIN_ID)
        save_user_ids()
    
    user_ids.add(message.from_user.id)
    save_user_ids()

    # Extract broadcast content
    try:
        command_args = message.text.split(' ', 1)
        broadcast_content = command_args[1] if len(command_args) > 1 else ""
    except Exception as e:
        await message.reply("‚ùå **Error parsing broadcast command**")
        return
    
    if not broadcast_content.strip():
        await message.reply("""üì¢ **Enhanced Broadcasting System with Custom Buttons**

**üìç Basic Broadcast:**
```
/broadcast Your message here
```

**üéõÔ∏è Broadcast with Buttons (Advanced):**
```
/broadcast Your main message content

BUTTON:Button Text 1|callback_data_1
BUTTON:Button Text 2|callback_data_2
URL:Website Link|https://example.com
URL:Join Channel|https://t.me/flex_public
```

**üìã Professional Examples:**

**Example 1 - Simple Announcement:**
```
/broadcast üöÄ New Update Available!
Premium features have been enhanced for better performance.
```

**Example 2 - Interactive Broadcast:**
```
/broadcast üéØ Welcome to Premium Services!
Access exclusive content with our latest features.

BUTTON:üîê Get Key|get_activation_key
BUTTON:üì± Download APK|get_premium_apk
URL:üì¢ Join Channel|https://t.me/flex_public
URL:üí¨ Support|https://t.me/support_chat
```

**Example 3 - Product Launch:**
```
/broadcast üî• BGMI Premium Launch!
Exclusive graphics pack now available for verified members.

BUTTON:‚ú® Get Graphics|graphics_pack
BUTTON:üéÆ Game APK|bgmi_premium
BUTTON:üîë Activation|premium_key
URL:üéØ Tutorial|https://tutorial.link
```

**üé® Button Format Rules:**
‚Ä¢ **BUTTON:** for callback buttons (bot actions)
‚Ä¢ **URL:** for web links  
‚Ä¢ Format: `TYPE:Display Text|action_data`
‚Ä¢ Max 8 buttons per message
‚Ä¢ Buttons appear in 2-column layout

**‚ö° Quick Commands:**
‚Ä¢ `/broadcast_test` - Send test broadcast to admin only
‚Ä¢ `/broadcast_stats` - View broadcast statistics""", parse_mode="Markdown")
        return

    # Parse message content and extract buttons
    lines = broadcast_content.split('\n')
    broadcast_text = ""
    buttons = []
    
    for line in lines:
        line = line.strip()
        
        if line.startswith('BUTTON:') or line.startswith('URL:'):
            try:
                # Parse button format: TYPE:Display Text|action_data
                button_type = line.split(':', 1)[0]
                button_content = line.split(':', 1)[1]
                
                if '|' in button_content:
                    button_text, button_data = button_content.split('|', 1)
                    button_text = button_text.strip()
                    button_data = button_data.strip()
                    
                    if button_type == 'BUTTON':
                        buttons.append(InlineKeyboardButton(text=button_text, callback_data=f"bc_{button_data}"))
                    elif button_type == 'URL':
                        buttons.append(InlineKeyboardButton(text=button_text, url=button_data))
                    
                    print(f"üîç BROADCAST: Added {button_type} - '{button_text}' -> '{button_data}'")
                else:
                    print(f"‚ö†Ô∏è BROADCAST: Invalid button format: {line}")
            except Exception as e:
                print(f"‚ùå BROADCAST: Error parsing button: {line} - {e}")
        else:
            if line:  # Only add non-empty lines
                broadcast_text += line + '\n'
    
    broadcast_text = broadcast_text.strip()
    
    if not broadcast_text:
        await message.reply("‚ùå **Empty broadcast message**")
        return

    # Create keyboard if buttons exist
    keyboard = None
    if buttons:
        # Group buttons into rows (2 per row max)
        button_rows = []
        for i in range(0, len(buttons), 2):
            button_rows.append(buttons[i:i+2])
        keyboard = InlineKeyboardMarkup(inline_keyboard=button_rows)
        print(f"üîç BROADCAST: Created keyboard with {len(button_rows)} rows, {len(buttons)} total buttons")

    # Track broadcasting progress
    sent_count = 0
    failed_count = 0
    
    status_msg = await message.reply("üì° **Starting Enhanced Broadcast...**\n\n‚è≥ Sending messages to all users...")
    
    print(f"üîç BROADCAST: Sending to {len(user_ids)} users")
    
    for user_id in user_ids:
        if user_id in blocked_users:
            print(f"üö´ BROADCAST: Skipping blocked user {user_id}")
            continue
            
        try:
            if keyboard:
                await bot.send_message(user_id, broadcast_text, parse_mode="Markdown", reply_markup=keyboard)
            else:
                await bot.send_message(user_id, broadcast_text, parse_mode="Markdown")
            sent_count += 1
            print(f"‚úÖ BROADCAST: Sent to user {user_id}")
            
            # Update status every 5 messages
            if sent_count % 5 == 0:
                try:
                    await status_msg.edit_text(f"üì° **Broadcasting...**\n\n‚úÖ Sent: {sent_count}\n‚ùå Failed: {failed_count}\nüéØ Buttons: {len(buttons)}\n‚è≥ In progress...")
                except:
                    pass
                
        except Exception as e:
            failed_count += 1
            print(f"‚ùå BROADCAST: Failed to send to {user_id}: {e}")
        
        # Rate limiting
        await asyncio.sleep(0.1)
    
    final_text = f"""üì° **Enhanced Broadcast Complete**

‚úÖ **Successfully sent:** {sent_count}
‚ùå **Failed:** {failed_count}
üë• **Total users:** {len(user_ids)}
üéØ **Buttons included:** {len(buttons)}
üö´ **Blocked users:** {len(blocked_users)}

üìä **Success rate:** {(sent_count/(sent_count+failed_count)*100) if (sent_count+failed_count) > 0 else 0:.1f}%

**Button Summary:**
{chr(10).join([f"‚Ä¢ {btn.text}" for btn in buttons[:5]])}
{"‚Ä¢ ..." if len(buttons) > 5 else ""}"""
    
    try:
        await status_msg.edit_text(final_text)
    except:
        await message.reply(final_text)

@dp.message(Command("broadcast_test"))
async def test_broadcast(message: Message):
    """Test broadcast functionality with admin only"""
    if message.from_user.id != ADMIN_ID:
        return
    
    test_message = """üß™ **Test Broadcast Message**

This is a test message to verify enhanced broadcast functionality with buttons.

Test completed successfully! ‚úÖ"""
    
    # Test buttons
    test_buttons = [
        [InlineKeyboardButton(text="üîê Test Key", callback_data="bc_test_key")],
        [InlineKeyboardButton(text="üì± Test APK", callback_data="bc_test_apk")],
        [InlineKeyboardButton(text="üåê Test URL", url="https://t.me/flex_public")]
    ]
    test_keyboard = InlineKeyboardMarkup(inline_keyboard=test_buttons)
    
    try:
        await bot.send_message(ADMIN_ID, test_message, parse_mode="Markdown", reply_markup=test_keyboard)
        await message.reply("‚úÖ **Test broadcast sent successfully to admin with buttons**")
    except Exception as e:
        await message.reply(f"‚ùå **Test broadcast failed:** {e}")

@dp.message(Command("broadcast_stats"))
async def broadcast_stats(message: Message):
    """Show detailed broadcast statistics"""
    if message.from_user.id != ADMIN_ID:
        return
    
    stats_text = f"""üìä **Enhanced Broadcast Statistics**

**User Database:**
üë• Total Users: {len(user_ids)}
‚úÖ Verified Users: {len(verified_users)}
üö´ Blocked Users: {len(blocked_users)}
üìà Active Users: {len(user_ids) - len(blocked_users)}

**System Status:**
ü§ñ Bot: Online & Enhanced
üì¢ Channel: {CHANNEL_ID}
üîë Admin ID: {ADMIN_ID}
‚ö° Features: Advanced Buttons Enabled

**Recent User IDs:**
{', '.join(map(str, list(user_ids)[-10:]))}

**Enhancement Features:**
üéõÔ∏è Custom Button Support
üì± URL Button Integration  
üîÑ Real-time Progress Tracking
üìä Detailed Statistics
üö´ Auto-skip Blocked Users"""
    
    await message.reply(stats_text)

# Handle custom broadcast button callbacks
@dp.callback_query(F.data.startswith("bc_"))
async def handle_broadcast_callbacks(callback_query: CallbackQuery):
    """Handle custom broadcast button callbacks"""
    try:
        await callback_query.answer("üéØ Processing your request...")
    except Exception:
        pass
    
    callback_data = callback_query.data[3:]  # Remove 'bc_' prefix
    user_id = callback_query.from_user.id
    
    print(f"üîç BROADCAST CALLBACK: User {user_id} clicked '{callback_data}'")
    
    # Handle different callback actions
    if callback_data in ['get_activation_key', 'premium_key', 'test_key']:
        await get_key_from_broadcast(callback_query)
    elif callback_data in ['get_premium_apk', 'bgmi_premium', 'test_apk']:
        await get_apk_from_broadcast(callback_query)
    elif callback_data == 'graphics_pack':
        await callback_query.message.reply("üé® **Graphics Pack**\n\nPremium graphics collection is being prepared for download!")
    else:
        # Generic response for custom callbacks
        await callback_query.message.reply(f"‚úÖ **Action Triggered**\n\nYou clicked: `{callback_data}`\n\nCustom action processed successfully!", parse_mode="Markdown")

async def get_key_from_broadcast(callback_query: CallbackQuery):
    """Handle key request from broadcast button"""
    user_id = callback_query.from_user.id
    
    if user_id in blocked_users:
        await callback_query.message.reply("üö´ **Access Denied**\n\nYour account has been restricted.")
        return
    
    is_member = await check_channel_membership(user_id)
    
    if not is_member:
        await callback_query.message.reply("‚ùå **Premium Membership Required**\n\nPlease join our channel first!", reply_markup=get_welcome_keyboard())
        return
    
    await show_typing_animation(user_id, ChatAction.TYPING)
    
    try:
        with open("key.txt", "r", encoding="utf-8") as f:
            key_text = f.read().strip()
        await bot.send_message(user_id, f"üîê **Premium Activation Key**\n\n`{key_text}`\n\n‚úÖ Requested via broadcast button!", parse_mode="Markdown")
    except FileNotFoundError:
        await callback_query.message.reply("‚ùå **Key Currently Unavailable**")

async def get_apk_from_broadcast(callback_query: CallbackQuery):
    """Handle APK request from broadcast button"""
    user_id = callback_query.from_user.id
    
    if user_id in blocked_users:
        await callback_query.message.reply("üö´ **Access Denied**\n\nYour account has been restricted.")
        return
    
    is_member = await check_channel_membership(user_id)
    
    if not is_member:
        await callback_query.message.reply("‚ùå **Premium Membership Required**\n\nPlease join our channel first!", reply_markup=get_welcome_keyboard())
        return
    
    await show_typing_animation(user_id, ChatAction.UPLOAD_DOCUMENT)
    
    try:
        with open("apk_file_id.txt", "r") as f:
            file_id = f.read().strip()
        with open("apk_caption.txt", "r", encoding="utf-8") as f:
            caption = f.read().strip()
        await bot.send_document(user_id, file_id, caption=caption + "\n\nüì± Requested via broadcast button!")
    except FileNotFoundError:
        await callback_query.message.reply("‚ùå **APK Currently Unavailable**")

# Admin commands for user management
@dp.message(Command("block"))
async def block_user(message: Message):
    if message.from_user.id != ADMIN_ID:
        return
    
    try:
        args = message.text.split()
        if len(args) < 2:
            await message.reply("**Usage:** `/block <user_id>`")
            return
        
        user_id = int(args[1])
        blocked_users.add(user_id)
        save_blocked_users()
        
        if user_id in verified_users:
            verified_users.remove(user_id)
            save_verified_users()
        
        await message.reply(f"‚úÖ **User {user_id} has been blocked**")
        
    except ValueError:
        await message.reply("‚ùå **Invalid user ID**")
    except Exception as e:
        await message.reply(f"‚ùå **Error:** {e}")

@dp.message(Command("unblock"))
async def unblock_user(message: Message):
    if message.from_user.id != ADMIN_ID:
        return
    
    try:
        args = message.text.split()
        if len(args) < 2:
            await message.reply("**Usage:** `/unblock <user_id>`")
            return
        
        user_id = int(args[1])
        if user_id in blocked_users:
            blocked_users.remove(user_id)
            save_blocked_users()
            await message.reply(f"‚úÖ **User {user_id} has been unblocked**")
        else:
            await message.reply(f"‚ÑπÔ∏è **User {user_id} was not blocked**")
            
    except ValueError:
        await message.reply("‚ùå **Invalid user ID**")
    except Exception as e:
        await message.reply(f"‚ùå **Error:** {e}")

@dp.message(Command("status"))
async def status_check(message: Message):
    try:
        if message.from_user.id != ADMIN_ID:
            return

        status_text = f"""ü§ñ **Bot Status Report**

üü¢ **Status:** Online & Running
üë• **Total Users:** {len(user_ids)}
‚úÖ **Verified Users:** {len(verified_users)}
üö´ **Blocked Users:** {len(blocked_users)}
üì¢ **Channel:** {CHANNEL_ID}
üîë **Admin ID:** {ADMIN_ID}"""

        await message.reply(status_text)
    except Exception as e:
        print(f"Error in status: {e}")

@dp.message(Command("help"))
async def admin_help(message: Message):
    try:
        if message.from_user.id != ADMIN_ID:
            return

        help_text = """üîß **Admin Commands**

**Content Management:**
‚Ä¢ `/setkey <key>` - Set activation key
‚Ä¢ `/setapk` - Upload APK (with file)

**User Management:**
‚Ä¢ `/block <user_id>` - Block a user
‚Ä¢ `/unblock <user_id>` - Unblock a user

**System:**
‚Ä¢ `/status` - Bot status
‚Ä¢ `/help` - This help message"""

        await message.reply(help_text, parse_mode="Markdown")
    except Exception as e:
        print(f"Error in help: {e}")

@dp.message(Command("testmembership"))
async def test_membership(message: Message):
    """Test membership check for current user"""
    if message.from_user.id != ADMIN_ID:
        return
    
    user_id = message.from_user.id
    
    # First show what we have in cache
    await message.reply(f"üîç **Testing membership for User ID:** `{user_id}`\n\n‚è≥ Checking...")
    
    # Clear user from verified list for testing
    if user_id in verified_users:
        verified_users.remove(user_id)
        save_verified_users()
    
    # Now test membership
    is_member = await check_channel_membership(user_id)
    
    try:
        # Get actual chat member info
        member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        actual_status = member.status
    except Exception as e:
        actual_status = f"Error: {e}"
    
    test_result = f"""üß™ **Membership Test Results**

**User ID:** `{user_id}`
**Channel:** `{CHANNEL_ID}`
**Actual API Status:** `{actual_status}`
**Our Check Result:** {'‚úÖ Member' if is_member else '‚ùå Not Member'}
**In Verified List:** {'‚úÖ Yes' if user_id in verified_users else '‚ùå No'}
**Is Admin:** {'‚úÖ Yes' if user_id == ADMIN_ID else '‚ùå No'}

**Debug Info:**
‚Ä¢ Total verified users: {len(verified_users)}
‚Ä¢ Bot Token: Active
‚Ä¢ Channel ID: {CHANNEL_ID}

**Bot Permission Check:**
Try `/checkchannel` to verify bot has access to channel."""
    
    await message.reply(test_result, parse_mode="Markdown")

@dp.message(Command("checkchannel"))
async def check_channel_access(message: Message):
    """Check if bot can access the channel"""
    if message.from_user.id != ADMIN_ID:
        return
    
    try:
        chat_info = await bot.get_chat(CHANNEL_ID)
        
        result = f"""üîç **Channel Access Test**

‚úÖ **Bot can access channel!**

**Channel Info:**
‚Ä¢ **Title:** {chat_info.title}
‚Ä¢ **Type:** {chat_info.type}
‚Ä¢ **ID:** `{chat_info.id}`
‚Ä¢ **Username:** @{chat_info.username if chat_info.username else 'No username'}
‚Ä¢ **Members Count:** {chat_info.member_count if hasattr(chat_info, 'member_count') else 'Unknown'}

**Bot Status:** Ready for membership checks ‚úÖ"""
        
        await message.reply(result, parse_mode="Markdown")
        
    except Exception as e:
        error_result = f"""‚ùå **Channel Access Failed**

**Error:** `{e}`

**Possible Issues:**
1. Bot is not admin in channel `{CHANNEL_ID}`
2. Channel doesn't exist or is private
3. Bot token is invalid
4. Channel ID format is wrong

**Solutions:**
1. Add bot as admin to {CHANNEL_ID}
2. Make sure channel exists and is public
3. Check bot token in secrets"""
        
        await message.reply(error_result, parse_mode="Markdown")

@dp.message(Command("forceverify"))
async def force_verify_user(message: Message):
    """Force verify a user for testing"""
    if message.from_user.id != ADMIN_ID:
        return
    
    args = message.text.split()
    if len(args) < 2:
        await message.reply("**Usage:** `/forceverify <user_id>`")
        return
    
    try:
        user_id = int(args[1])
        verified_users.add(user_id)
        save_verified_users()
        await message.reply(f"‚úÖ **Force verified user:** `{user_id}`\n\nThey can now access premium features.")
    except ValueError:
        await message.reply("‚ùå **Invalid user ID**")

@dp.message(Command("adminhelp"))
async def admin_help_detailed(message: Message):
    if message.from_user.id != ADMIN_ID:
        await message.reply(f"‚ùå **Access Denied**\n\nYour ID: `{message.from_user.id}`\nAdmin ID: `{ADMIN_ID}`")
        return

    help_text = """üîß **FlexBot Administrative Command Center**

**üìù Content Management Commands:**
‚Ä¢ `/setkey <text>` - Configure premium activation key
‚Ä¢ `/setapk` (with file attachment) - Upload premium APK package

**üë• User Management Operations:**  
‚Ä¢ `/block <user_id>` - Restrict user access to services
‚Ä¢ `/unblock <user_id>` - Restore user access privileges

**üì¢ Broadcasting & Communication:**
‚Ä¢ `/broadcast <message>` - Send announcements to all users
‚Ä¢ `/broadcast_test` - Test broadcast functionality with admin
‚Ä¢ `/broadcast_stats` - View detailed broadcast statistics

**Enhanced Broadcasting Features:**
Add interactive buttons using format:
```
BUTTON:Button Text|callback_data
URL:Button Text|https://link.com
```

**üìä System Monitoring:**
‚Ä¢ `/status` - View comprehensive system dashboard
‚Ä¢ `/help` - Basic admin commands
‚Ä¢ `/adminhelp` - This detailed command reference

**üß™ Debug & Testing:**
‚Ä¢ `/testmembership` - Test membership check system
‚Ä¢ `/checkchannel` - Verify bot channel access
‚Ä¢ `/forceverify <user_id>` - Force verify user for testing

**üì± Professional Broadcast Example:**
```
/broadcast üöÄ Premium Update Available!
Access the latest features now.

BUTTON:üîê Get Key|get_activation_key
BUTTON:üì± Download APK|get_premium_apk
URL:üåü Join Channel|https://t.me/flex_public
```

**üéØ All commands are admin-exclusive and secured.**
**üìà Current Status:** Bot Online & Enhanced Features Active"""

    await message.reply(help_text, parse_mode="Markdown")

@dp.message(F.text)
async def handle_text_messages(message: Message):
    try:
        text = message.text.lower()
        user_id = message.from_user.id

        if user_id in blocked_users:
            return

        key_triggers = ['key', 'activation', 'code', 'password', 'unlock']
        apk_triggers = ['apk', 'app', 'download', 'file', 'bgmi']

        if any(trigger in text for trigger in key_triggers):
            is_member = await check_channel_membership(user_id)
            if not is_member:
                await message.reply("‚ùå **Premium Membership Required**", reply_markup=get_welcome_keyboard())
                return

            await show_typing_animation(user_id, ChatAction.TYPING)
            try:
                with open("key.txt", "r", encoding="utf-8") as f:
                    key_text = f.read().strip()
                await bot.send_message(user_id, f"üîê **Premium Key**\n\n`{key_text}`", parse_mode="Markdown")
            except FileNotFoundError:
                await message.reply("‚ùå **Key unavailable at the moment**")

        elif any(trigger in text for trigger in apk_triggers):
            is_member = await check_channel_membership(user_id)
            if not is_member:
                await message.reply("‚ùå **Premium Membership Required**", reply_markup=get_welcome_keyboard())
                return

            await show_typing_animation(user_id, ChatAction.UPLOAD_DOCUMENT)
            try:
                with open("apk_file_id.txt", "r") as f:
                    file_id = f.read().strip()
                with open("apk_caption.txt", "r", encoding="utf-8") as f:
                    caption = f.read().strip()
                await bot.send_document(user_id, file_id, caption=caption)
            except FileNotFoundError:
                await message.reply("‚ùå **APK currently unavailable**")
        else:
            await message.reply("üéØ **How can I help you?**", reply_markup=get_content_keyboard())
    except Exception as e:
        print(f"Error in text handler: {e}")

async def main():
    print("ü§ñ Starting FlexBot Premium Services...")
    print(f"üì¢ Channel: {CHANNEL_ID}")
    print(f"üîë Admin ID: {ADMIN_ID}")
    print(f"üë• Loaded {len(user_ids)} users")
    print(f"‚úÖ Loaded {len(verified_users)} verified users")
    print(f"üö´ Loaded {len(blocked_users)} blocked users")
    print("üéõÔ∏è Enhanced broadcast with custom buttons enabled")

    try:
        print("üöÄ Bot starting polling...")
        await dp.start_polling(bot, skip_updates=True)
    except KeyboardInterrupt:
        print("üõë Bot stopped by user")
    except Exception as e:
        print(f"‚ùå Bot error: {e}")
        # Try to restart after error
        await asyncio.sleep(5)
        print("üîÑ Attempting to restart...")
        await main()
    finally:
        try:
            await bot.session.close()
        except:
            pass

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("üõë Bot stopped")
    except Exception as e:
        print(f"‚ùå Critical error: {e}")